= Development guide

== Project structure

The project is a multi-module Maven project.

.Module dependency tree diagram
image::modules.dot.svg[align="center"]

At the bottom of the module tree there are the backend and frontend modules,
which contain the application source code.

The standalone module is an assembly module that combines backend and frontend into a single executable JAR file.

The distribution module represents the final assembly step.
It takes the standalone application and the documentation and wraps them in an archive that is easy to distribute.

== Backend

Backend module contains a server-side application that uses OptaPlanner to *optimize vehicle routes*.
It is a CPU-intensive computation, that must avoid any I/O operations in order to perform to its full potential.
Because one of the chief objectives is to minimize the travel cost, be it time or distance,
we need to keep the travel cost information in RAM memory.
While solving, OptaPlanner needs to know the travel cost between every pair of locations that the user has entered.
This information is stored in a structure called the _distance matrix_.

When a new location is entered, we calculate the travel cost between the new location and every other location that has been entered so far, and store it in the distance matrix.
The travel cost calculation is performed by a routing engine called https://github.com/graphhopper/graphhopper[GraphHopper].

Finally, the backend module implements additional functionality like

- persistence,
- WebSocket connection for the frontend,
- data set loading, export and import.

=== Design and source code organization

Domain model and use cases are essential for the application.
We put domain model at the center of the architecture and surround it by the application layer, that embeds use cases.
Functions such as route optimization, distance calculation, persistence, and network communication are considered implementation details
and are placed at the outermost layer of the architecture.

// TODO picture

==== Project structure

[literal]
....
org.optaweb.vehiclerouting
├── domain
├── plugin
│   ├── persistence
│   ├── planner
│   ├── routing
│   └── websocket
└── service
    ├── demo
    ├── distance
    ├── location
    └── route
....

===== Root package

The root package name is identical to the Maven Group ID of the project
(`org.optaweb.vehiclerouting`).
It contains a class annotated with `@SpringBootApplication`,
which enables Spring auto-configuration and component scanning in sub-packages.

===== Domain package

Contains "business objects" that model the domain of this project,
for example Visit, Depot, Location, Vehicle.
These objects are strictly business-oriented and must not be influenced
by any tools and frameworks (e.g. ORM, marshalling formats etc.).

===== Services package

Contains classes that implement "use cases".
A use case is for example adding new location, changing vehicle capacity
or finding coordinates for an address.
The business rules that govern use cases are expressed using the domain objects.

Use cases often need to interact with outer layers, such as persistence, web and
optimization.
To keep the code loosely coupled, the interaction with the outer layers
is expressed in terms of interfaces.
Their implementations are provided by Spring IoC container at runtime.

===== Plugins package

Contains outer layers such as optimization, persistence, routing and web.

==== Dependency rules

Compile-time dependencies are only allowed in the direction from outer layers towards the center.
This means plugins -> services -> domain.

The domain has no dependencies.

Services only depend on the domain.
If a service needs to send a result (e.g. to a database or web socket), it uses an output boundary interface.
Its implementation is injected by the IoC container.

Plugins depend on services in two ways.
Firstly, they invoke services based on events such as a user input or a route update coming from the optimization engine.
Services are injected into plugins, which moves the burden of their construction and dependency resolution to the IoC container.
Secondly, plugins implement services' output boundary interfaces to handle use case results, e.g. persisting changes to database, sending response to web UI.

== Frontend

== Standalone

== Documentation

== Distribution

== Building the project

Run `./mvnw install` or `mvn install`.

== Developing backend

////
- OptaPlanner, GraphHopper
- Spring Boot
- Configuration (`application.properties`, `application-*.properties`)
- Package structure
- DevTools
- Docker
////

== Developing frontend

////
- PatternFly, Leaflet
- Npm, React, Redux, TypeScript, ESLint, Cypress, `ncu`
- Chrome, plugins
- Docker
////
