[appendix]
= Backend architecture

Domain model and use cases are essential for the application.
We put domain model at the center of the architecture and surround it by the application layer, that embeds use cases.
Functions such as route optimization, distance calculation, persistence, and network communication are considered implementation details
and are placed at the outermost layer of the architecture.

.Diagram of application layers
image::backend-layers.svg[align="center"]

== Code organization

The backend code is organized in three layers outlined above.

[literal]
....
org.optaweb.vehiclerouting
├── domain
├── plugin          # Infrastructure layer
│   ├── persistence
│   ├── planner
│   ├── routing
│   └── websocket
└── service         # Application layer
    ├── demo
    ├── distance
    ├── location
    ├── region
    ├── reload
    ├── route
    └── vehicle
....

The `service` package contains the application layer, implementing use cases.
The `plugin` package contains the infrastructure layer.

Code in each layer is further organized by function.
That means each service or plugin has its own package.

== Dependency rules

Compile-time dependencies are only allowed to point from outer layers towards the center.
Following this rule helps to keep domain model independent of underlying frameworks and other implementation details,
and model the behavior of business entities more precisely.
With presentation and persistence being pushed out to the periphery, it is easier to test the behavior of business entities and use cases.

The domain has no dependencies.

Services only depend on the domain.
If a service needs to send a result (e.g. to a database or web socket), it uses an output boundary interface.
Its implementation is injected by the IoC container.

Plugins depend on services in two ways.
Firstly, they invoke services based on events such as a user input or a route update coming from the optimization engine.
Services are injected into plugins, which moves the burden of their construction and dependency resolution to the IoC container.
Secondly, plugins implement services' output boundary interfaces to handle use case results, e.g. persisting changes to database, sending response to web UI.

== Domain package

The `domain` package contains "business objects" that model the domain of this project,
for example Visit, Depot, Location, Vehicle.
These objects are strictly business-oriented and must not be influenced
by any tools and frameworks (e.g. ORM, marshalling formats etc.).

== Services package

The `service` package contains classes that implement "use cases".
A use case is for example adding new location, changing vehicle capacity or finding coordinates for an address.
The business rules that govern use cases are expressed using the domain objects.

Use cases often need to interact with outer layers, such as persistence, web and optimization.
To keep the code loosely coupled, the interaction with the outer layers is expressed in terms of interfaces.
Their implementations are provided by Spring IoC container at runtime.

== Plugins package

The `plugin` package contains infrastructure functions such as optimization, persistence, routing and network.
